# 티켓 판매 애플리케이션 구현하기

소극장의 홍보 및 관람객의 유입을 위해 이벤트를 기획
- 시나리오
  - 추첨을 통해 선정된 관람객에게 공연을 무료로 관람 할 수 있는 초대장을 발송한다.
- 제약사항
  - 이벤트에 당첨된 관람객과, 그렇지 못한 관람객은 다른 방식으로 입장시켜야 한다.
  - 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환 한 후에 입장 할 수 있다.
  - 이벤트에 당첨되지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.
  - 입장전, 이벤트 당첨 여부를 확인해야 하고 이벤트 장첨자가 아닌 경우, 티켓을 판매한 후에 입장시켜야 한다.

### 초대장
- 공연을 관람 할 수 있는 초대 일자 를 가지고 있다.

### 티켓
- 공연을 관람하기 원하는 모든 사람들은 티켓을 소지하고 있다.

### 가방
- 관람객이 소지품을 보관할 수 있는 가방이다.
- 아래와 같은 소지품을 가질 수 있다.
  - 초대장
  - 티켓
  - 현금

### 관람객
- 관람객은 소지품을 보관하기 위해 가방을 소지 할 수 있다.

### 매표소
- 관람객이 소극장에 입장하기 위해서는 매표소에서 초대장을 티켓으로 교환하거나 구매해야 한다.
- 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관돼 있어야 한다.

### 클래스 다이어그램
![img.png](img.png)


### 문제점
- 로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 목적으로 다음과 같이 꼽았다.
  - 실행 중에 제대로 동작할것
  - 변경을 위해 존재할것
  - 코드를 읽는 사람과 의사소통 할 것
- 마틴에 따르면 제대로 실행되고, 변경이 용이해야 하며, 이해하기 쉬어야 한다.
- 따라서 현재까지 의 기능은 제대로 실행됨을 만족하지만, 변경과 읽는사람과의 의사소통은 만족 시키지 못했다.

### 예상을 빗나가는 코드
- 소극장은 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 살펴본다.
- 가방 안에 초대장이 들어 있으면 판 매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다. 
- 가방 안에 초대장이 들어 있지 않다면 관 람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후에 매표소에 보관돼 있는 티켓을 관람객 의 가방 안으로 옮긴다.
> 문제는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 이다. <br/>
> 내 자신이 관람객이라고 가정해볼때, <br/> 
> 본인 입장에서 문제는 소극장이라는 제3자가 초대장을 확인 하기 위해 내 가방을 마음대로 열어 본다. <br/> 
> 만약 누군가가 내 허락 없이 가방 안 의 내용물을 마음대로 뒤적이고 돈을 가져간다면 몹시 기분이 불쾌할 것 같다. (예쁘면 봐준다.) <br/> 
> 넋놓고 다른 사람이 내 가방을 헤 집어 놓는 것을 멍하니 바라만 볼 사람은 없다. </br>

> 본인이 판매원이라고 하더라도 동일한 문제가 발생한다. <br/> 
> 소극장이 본인의 허락도 없이 매표소에 보관 중인 티켓과 현금에 마음대로 접근할 수 있기 때문이다. <br/> 
> 더 큰 문제는 티켓을 꺼내 관람객의 가 방에 집어넣고 관람객에게서 받은 돈을 매표소에 적립하는 일은 본인이 아닌 소극장이 수행한다는 점이다. <br/>
> 본인은 매표소 안에 가만히 앉아 티켓이 하나씩 사라지고 돈이 저절로 쌓이는 광경을 두 손 놓고 쳐다볼 수밖에 없는 것이다. <br/>

### 이해 가능한 코드란 ?
- 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드를 의미한다.

### 현실에서는 ?
- 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.
- 티켓을 구매하는 관람객은 가방 안에서 돈을 직접 꺼내 판매원에게 지불한다.
- 판매원은 매표소에 있는 티켓을 직접꺼내 관람객에게 건네고 관람객에게서 직접 돈을 받아 매표소에 보관한다.
- 하지만 코드 안의 관람객, 판매원은 그렇게 하지 않는다.

### 변경에 취약한 코드
- 현재 상황에서는 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다고 가정하고, 판매원이 매표소에서만 티켓을 판매한다고 가정한다.
  - 관람객이 가방을 안들고 다닌다면 ? 
  - 또 현금이 아니라 신용카드를 이용해서 결제한다면 ? 
  - 판매원이 매표소 밖에서 티켓을 판매한다고 한다면 ? 

> 의존성 <br/>
> 객체 사이의 의존성은 변경과 관련되어 있다. <br/>
> 말 그대로 객체가 변경되었을때 해당 객체를 의존하는 다른 객체도 같이 변경되는것 을 의미한다. <br/>
> 객체 사이의 의존성이 과한 경우를 가리켜 우리는 결합도 (Coupling) 이 높다고 말한다. <br/>
> 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다 <br/>

# 설계 개선하기
### 현재로썬, 하나만 만족 한 상태이다 
- [x] 제대로 동작 한다
- [ ] 변경이 용이 한다
- [ ] 읽기가 쉽다

### 왜 코드를 읽기가 불편한 것인가? 
- Theater 가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다.
- 관람객과 판매원이 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어났기 때문.
  - 의도를 정확하게 의사소통 하지 못하기 때문에 코드가 이해하기 어려워진 것이다.
  - Theater 가 관람객의 가방과 판매원의 매표소에 직접 접근한다는 것은 Theater 가 Audience 와 TicketSeller 에 결합된다는 것을 의미한다.
  - 따라서 Audience 와 TicketSeller 를 변경할 때 Theater 도 함께 변경해야 하기 때문에 전체적으로 코드를 변경하기도 어려워진다.

### 그래서 솔루션은 ?
- Theater 가 Audience 와 TicketSeller 에 관해 너무 세세한 부분까지 알지 못하도록 차단하는것.
> 다시말해 `자율적인 존재` 가 되게끔 만들면 된다.

### TicketOffice 에 접근하는 코드를 ticketOffice 를 포함하는 TicketSeller 로 이동
![img_2.png](img_2.png)

### 수정된 Theater 는 이제 어디서도 TicketOffice 에 접근 하지 않는다는 사실이 핵심이다
![img_1.png](img_1.png)

> ticketSeller 에서 getTicketOffice 메서드가 제거된것이 가장 핵심이다. <br/>
> 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 우리는 캡슐화 라고 부른다. <br/>
> 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다. <br/>


> Theater 는 오직 TicketSeller 의 인터페이스(interface) 에만 의존한다. TicketSeller 가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 <br/>
> 구현 (implementation) 의 영역에 속한다. <br/>
> 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다. <br/>

### Theater 의 결합도를 낮춘 설계.
![img_3.png](img_3.png)

### Audience 를 캡슐화 해보자.
- TicketSeller 다음으로 Audience 도 개선해야한다.
- TicketSeller 는 Audience 의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근한다.
  - Bag 인스턴스에 접근하는 객체가 Theater 에서 TicketSeller 로 바뀌었을 뿐 Audience 는 여전히 자율적인 존재가 아닌 것이다.
- TicketSeller 와 동일한 방법으로 Audience 의 캡슐화를 개선할 수 있다. 
  - Bag 에 접근하는 모든 로직을 Audience 내부로 감추기 위해 Audience 에 buy 메서드를 추가하고 TicketSeller 의 sellTo 메서드에서 getBag 메서드에 접근하는 부분을 buy 메서드로 옮겨보자.




